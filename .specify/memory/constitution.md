<!-- SYNC IMPACT REPORT
Version change: 2.0.0 → 3.0.0
Modified principles:
- Spec-driven development → Spec-driven development (Phase IV expanded)
- Technology stack constraints updated to reflect cloud-native Kubernetes deployment
Added new principles: Cloud-native infrastructure automation, Containerization standards, Kubernetes deployment standards, Helm chart governance
Technology stack updated to reflect Phase IV requirements
Added new sections: Cloud-native infrastructure, Containerization governance, Kubernetes deployment constraints
Removed sections: None
Added sections: Cloud-native infrastructure automation, Containerization standards, Kubernetes deployment standards, Helm chart governance, Minikube-specific requirements
Templates requiring updates:
  - .specify/templates/plan-template.md ⚠ pending
  - .specify/templates/spec-template.md ⚠ pending
  - .specify/templates/tasks-template.md ⚠ pending
  - .specify/templates/commands/sp.constitution.md ⚠ pending
Follow-up TODOs: None
-->

# Todo Full-Stack Web Application Constitution - Cloud-Native Kubernetes Deployment

## Core Principles

### Spec-driven development
All features must be derived strictly from written specifications; No undocumented behavior allowed; Every implementation must map directly to a spec requirement; All infrastructure and deployment operations must follow written specs; AI-assisted DevOps must adhere to agentic dev stack workflow (Write Spec → Generate Plan → Break into Tasks → Implement via Claude Code)

### Agentic-first design
AI agents operate the system via tools, not hardcoded logic; All AI actions must be executed exclusively through MCP tools; Deterministic mapping of natural language commands to defined tools; AI-driven actions must follow predefined tool interfaces; All cloud-native operations must be executed through AI-assisted tools (kubectl-ai, kagent, Docker AI Agent)

### Cloud-native infrastructure automation
All deployment and infrastructure must be automated through code; Manual Kubernetes YAML creation is prohibited unless generated by AI tools; Containerization must follow cloud-native best practices; Infrastructure as Code must be used for all deployments; Local Kubernetes deployment required using Minikube

### Containerization standards
Frontend and backend must be containerized using Docker; Dockerfiles must be generated via Docker AI Agent (Gordon) or Claude Code; Images must be optimized for size and security; Container build process must be reproducible; Both frontend and backend services must run in separate containers

### Kubernetes deployment standards
All deployments must run on Minikube locally; Kubernetes manifests must be generated via AI tools (kubectl-ai, kagent) or Helm Charts; Raw YAML files must not be written manually unless generated by AI; Services, deployments, and configurations must follow Kubernetes best practices; Multi-container orchestration required for frontend and backend

### Helm chart governance
Helm charts must be created for application packaging; Both frontend and backend must have separate or combined Helm charts; Chart templates must be parameterizable and reusable; Versioning must follow semantic versioning for charts; Chart deployments must be idempotent

### Stateless server architecture with persistent memory
Backend must remain stateless across requests; Conversation state must be reconstructed from stored messages on every request; MCP tools must be stateless and persist all changes to the database; AI agents must not directly access the database; Containerized services must not maintain ephemeral state

### Safety and correctness in AI-driven actions
Authentication and user isolation must be enforced on all AI operations; MCP tools must validate inputs and prevent unsafe operations; All AI operations must be auditable and traceable; Error handling must be robust for AI-generated requests; Kubernetes operations must be validated before execution

### Security-first architecture
Authentication and authorization must be enforced by design; JWT-based verification required; User data isolation is mandatory; Security considerations must be addressed at every layer; AI operations must respect user boundaries; Container and Kubernetes security best practices must be followed

### User data isolation
Each user can only view and modify their own tasks; No cross-user data leakage permitted; Backend must enforce user ownership at every data operation; Multi-user system required with no single-user assumptions; AI agents must respect user identity in all operations; Data persistence must maintain user separation in Kubernetes deployment

### Reliability and correctness
API behavior must be predictable and testable; REST endpoints must follow standard HTTP semantics; Proper status codes and error handling required; All CRUD operations must work reliably with persistent storage; AI operations must have deterministic outcomes; Kubernetes deployments must be reliable and recoverable

### Modern full-stack best practices
Frontend and backend must be properly separated; Next.js 16+ with App Router for frontend; Python FastAPI for backend; SQLModel ORM for database operations; Neon Serverless PostgreSQL for storage; Containerization using Docker; Kubernetes orchestration using Minikube; Helm-based deployment

## MCP Tool Standards
- All AI actions must be executed exclusively through MCP tools
- MCP tools must be stateless and persist all changes to the database
- AI agents must not directly access the database
- MCP tools must provide clear interfaces for AI operations
- MCP tools must validate all inputs and enforce security constraints
- MCP tools must support containerization and Kubernetes operations

## AI Operation Constraints
- AI Framework: OpenAI Agents SDK (when applicable)
- Natural language commands must map deterministically to defined tools
- AI agents must follow defined workflows without improvisation
- All AI operations must be authenticated and authorized
- AI operations must respect user isolation and data privacy
- AI-assisted Kubernetes operations must follow defined tool interfaces
- Docker AI Agent (Gordon) preferred for containerization tasks
- kubectl-ai and kagent for Kubernetes operations

## Conversation State Management
- Conversation state must be reconstructed from stored messages on every request
- Backend must remain stateless across requests
- Message history must be persisted in database
- Conversation context must be maintained through session identifiers
- AI agents must work with reconstructed conversation state only
- Containerized services must maintain state persistence through external storage

## Technology Stack Constraints
- Frontend: Next.js 16+ with App Router (containerized)
- Backend: Python FastAPI (containerized)
- Containerization: Docker with Docker AI Agent (Gordon) preferred
- Orchestration: Kubernetes via Minikube
- Package Manager: Helm for application deployment
- AI-assisted Operations: kubectl-ai, kagent for Kubernetes
- ORM: SQLModel
- Database: Neon Serverless PostgreSQL (externally managed)
- Authentication: Better Auth with JWT
- Architecture: Containerized frontend and backend as separate services
- Storage: Persistent database only (no in-memory task storage)
- Multi-user system required (single-user assumptions forbidden)
- MCP tools for AI operations
- Local Kubernetes deployment using Minikube only

## Development Workflow
- All features must map directly to written specs (no undocumented behavior)
- REST API must follow standard HTTP semantics (status codes, methods)
- Backend must enforce user ownership at every data operation
- Database operations must use ORM (SQLModel) with schema consistency
- Frontend must consume API only through authenticated requests
- No hardcoded secrets (all secrets via environment variables)
- Unauthorized requests must return proper 401 responses
- MCP tools must be stateless and persist changes to database
- AI operations must be validated through tools, not direct access
- Containerization must follow AI-assisted approach using Docker AI Agent
- Kubernetes deployments must follow AI-assisted approach using kubectl-ai or kagent
- Helm charts must be used for application packaging and deployment
- Manual YAML writing is prohibited unless generated by AI tools

## Cloud-native Infrastructure Requirements
- All services must be containerized before Kubernetes deployment
- Dockerfiles must be optimized for security and size
- Container images must be built and pushed to registry (local for Minikube)
- Kubernetes resources must be deployed via Helm charts
- Service discovery must work within the cluster
- Environment variables must be properly configured for containerized services
- Health checks must be implemented for Kubernetes readiness/liveness probes

## Minikube-specific Requirements
- Local-only Kubernetes cluster using Minikube
- All deployments must be tested on Minikube environment
- Resource limits must be appropriate for local development
- Persistent volumes must be configured for database storage
- Ingress controllers may be used for local service exposure
- Minikube addons may be leveraged for additional functionality

## Governance
This constitution supersedes all other development practices; All implementations must comply with these principles; Amendments require proper documentation and approval; Every pull request must verify constitution compliance; AI operations must adhere to defined tool interfaces; Kubernetes deployments must follow cloud-native best practices; Containerization and orchestration must be automated via AI-assisted tools

**Version**: 3.0.0 | **Ratified**: 2026-01-08 | **Last Amended**: 2026-02-07
